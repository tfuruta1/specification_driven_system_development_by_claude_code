# 📖 既存プロジェクト解析のためのSDD拡張仕様

## 🎯 概要
既存プロジェクトの解析・修正において、KIRO方式のSDDルールを応用し、要件定義書・技術設計書を自動生成・更新することで、解析時間を大幅に短縮する仕組みを構築します。

## 🔄 基本コンセプト

### 原則
1. **ソースコードが正（Single Source of Truth）**
2. **要件定義書・技術設計書は解析キャッシュとして機能**
3. **差分検出による効率的な更新**
4. **自動同期メカニズムによる整合性維持**

## 📊 解析フロー

### 初回解析時
```mermaid
graph TD
    A[既存プロジェクト] --> B[/analyze コマンド実行]
    B --> C[ソースコード解析]
    C --> D[要件定義書自動生成]
    C --> E[技術設計書自動生成]
    D --> F[.claude/specs/existing/]
    E --> F
    F --> G[解析完了]
```

### 2回目以降の解析時
```mermaid
graph TD
    A[既存プロジェクト] --> B[/analyze コマンド実行]
    B --> C{設計書存在？}
    C -->|Yes| D[設計書読み込み]
    C -->|No| E[初回解析フロー]
    D --> F[ソースコードとの差分チェック]
    F --> G{差分あり？}
    G -->|Yes| H[設計書自動更新]
    G -->|No| I[設計書から情報取得]
    H --> J[更新通知]
    I --> K[高速解析完了]
    J --> K
```

## 📁 ディレクトリ構造

```
.claude/
├── specs/
│   ├── existing/              # 既存プロジェクト解析結果
│   │   ├── [project-name]/
│   │   │   ├── requirements/  # 要件定義書
│   │   │   │   ├── current.md     # 現在の要件定義
│   │   │   │   ├── history/       # 変更履歴
│   │   │   │   └── checksums.json # ファイルハッシュ値
│   │   │   ├── design/        # 技術設計書
│   │   │   │   ├── current.md     # 現在の技術設計
│   │   │   │   ├── architecture/  # アーキテクチャ図
│   │   │   │   ├── history/       # 変更履歴
│   │   │   │   └── checksums.json # ファイルハッシュ値
│   │   │   └── metadata.json  # プロジェクトメタデータ
│   └── new/                   # 新規開発プロジェクト（既存）
```

## 🛠️ 新規コマンド体系

### /analyze - 既存プロジェクト解析
```bash
# 初回解析（設計書生成）
/analyze [project-path] --generate-docs

# 高速解析（設計書活用）
/analyze [project-path] --use-cache

# 強制再解析
/analyze [project-path] --force-refresh

# 差分解析
/analyze [project-path] --diff-only
```

### /sync-docs - 設計書同期
```bash
# 手動同期
/sync-docs [project-path]

# 自動同期設定
/sync-docs --auto --interval=on-change

# 同期状態確認
/sync-docs --status
```

### /validate-docs - 整合性検証
```bash
# 設計書とソースコードの整合性チェック
/validate-docs [project-path]

# 不整合箇所の自動修正
/validate-docs --auto-fix
```

## 📝 要件定義書・技術設計書の構造

### 要件定義書テンプレート
```markdown
# 要件定義書 - [プロジェクト名]

## メタデータ
- 生成日時: [timestamp]
- 最終更新: [timestamp]
- ソースコードハッシュ: [hash]
- 解析バージョン: [version]

## システム概要
[自動解析による概要]

## 機能要件
### 識別された機能一覧
1. [機能名]: [説明]
2. ...

## 非機能要件
### パフォーマンス
[解析結果]

### セキュリティ
[解析結果]

## API仕様
[エンドポイント一覧]

## データモデル
[テーブル/エンティティ構造]

## 依存関係
[外部ライブラリ/サービス]
```

### 技術設計書テンプレート
```markdown
# 技術設計書 - [プロジェクト名]

## メタデータ
- 生成日時: [timestamp]
- 最終更新: [timestamp]
- ソースコードハッシュ: [hash]
- 解析バージョン: [version]

## アーキテクチャ概要
[レイヤー構造/パターン]

## モジュール構成
### ディレクトリ構造
[ツリー表示]

### 主要コンポーネント
[コンポーネント図]

## クラス設計
### クラス図
[主要クラスの関係]

### インターフェース定義
[公開API]

## データフロー
[処理の流れ]

## 技術スタック
- 言語: [version]
- フレームワーク: [version]
- ライブラリ: [一覧]

## コード品質メトリクス
- 複雑度: [値]
- テストカバレッジ: [%]
- 技術的負債: [評価]
```

## 🔄 同期メカニズム

### チェックサム管理
```json
{
  "project": "project-name",
  "files": {
    "src/main.js": {
      "hash": "sha256:abc123...",
      "lastModified": "2024-01-15T10:00:00Z",
      "analyzed": true
    }
  },
  "lastSync": "2024-01-15T10:30:00Z"
}
```

### 差分検出アルゴリズム
1. ファイルハッシュ値の比較
2. 変更ファイルのみ再解析
3. 影響範囲の特定
4. 設計書の該当箇所のみ更新

## 🤖 AI活用ポイント

### Gemini-CLI連携
- 大規模コードベースの高速解析
- 複雑な依存関係の可視化
- 自然言語での要件抽出

### o3 MCP連携
- システム全体のアーキテクチャ分析
- セキュリティ脆弱性の検出
- パフォーマンスボトルネックの特定

### Claude Code内蔵
- 基本的なコード解析
- 設計書の生成と更新
- 差分検出と同期

## 📈 期待される効果

### 時間短縮
- **初回解析**: 100% (基準値)
- **2回目以降**: 20-30% (70-80%削減)
- **差分のみ**: 5-10% (90-95%削減)

### 品質向上
- 設計書の自動更新による陳腐化防止
- ソースコードとの一貫性保証
- 変更履歴の自動記録

### 開発効率
- 既存機能の理解時間短縮
- 影響範囲の即座の把握
- リファクタリング時の安全性向上

## ⚠️ 注意事項

### 設計書の扱い
1. **常にソースコードが正**
2. 設計書は参考情報として活用
3. 不整合時は自動的にソースコードに合わせる

### 更新タイミング
- コミット時に自動更新（推奨）
- 手動実行も可能
- 大規模変更時は強制再解析

### バージョン管理
- 設計書も.gitignoreに含めない
- 変更履歴を保持
- ロールバック可能な構造

## 🚀 実装計画

### Phase 1: 基本機能（1週間）
- [ ] /analyzeコマンドの実装
- [ ] 要件定義書自動生成
- [ ] 技術設計書自動生成

### Phase 2: キャッシュ機能（2週間）
- [ ] チェックサム管理
- [ ] 差分検出
- [ ] 高速解析モード

### Phase 3: 同期機能（2週間）
- [ ] 自動同期メカニズム
- [ ] 整合性検証
- [ ] Git hooks統合

### Phase 4: 最適化（1ヶ月）
- [ ] MCP連携による高度な解析
- [ ] インクリメンタル更新
- [ ] パフォーマンスチューニング

---

*この仕様により、既存プロジェクトの解析時間を大幅に短縮し、常に最新の設計書を維持することが可能になります。*